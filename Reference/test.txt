//inquire_restful_api.js
const express = require('express');
const {
    MongoClient,
    ObjectId
} = require("mongodb");

const router = express.Router();

// Replace the uri string with your connection string.
const uri = "mongodb://localhost:27017";
const client = new MongoClient(uri);

/* This code block defines CRUD (Create, Read, Update, Delete) operations for a collection named
`inquire_messages` in a MongoDB database named `inquire_db`. Here's a breakdown of what each part of
the code does: */
// CRUD operations for inquire_db/inquires
// Create
router.post('/inquires/create', async (req, res, next) => {
    try {
        await client.connect();
        const {
            sender,
            timestamp,
            user,
            min_gar,
            max_gar,
            min_ash,
            max_ash,
            volume,
            laycan,
            port
        } = req.body;

        const requiredFields = {
            sender,
            timestamp,
            user,
            min_gar,
            max_gar,
            min_ash,
            max_ash,
            volume,
            laycan,
            port
        };
        const missingFields = Object.entries(requiredFields).filter(([key, value]) => !value).map(([key]) => key);

        if (missingFields.length > 0) {
            return res.status(400).json({
                error: 'Incomplete data',
                missing: missingFields
            });
        }

        const database = client.db('inquire_db');
        const inquire_messages = database.collection('inquire_messages');

        const existingInquire = await inquire_messages.findOne({
            sender,
            timestamp,
            'user._id': user._id
        });

        if (!existingInquire && user.wa_id) {
            const existingInquireByWaId = await inquire_messages.findOne({
                sender,
                timestamp,
                'user.wa_id': user.wa_id
            });
            if (existingInquireByWaId) return res.status(200).json({
                message: 'Entry already exists'
            });
        }

        if (!existingInquire) {
            const result = await inquire_messages.insertOne(req.body);
            return res.json({
                id: result.insertedId
            });
        }

        return res.status(200).json({
            message: 'Entry already exists'
        });
    } catch (error) {
        next(error);
    }
});

// Read
router.get('/inquires/read', async (req, res, next) => {
    try {
        await client.connect();
        const database = client.db('inquire_db');
        const inquire_messages = database.collection('inquire_messages');
        const allInquires = await inquire_messages.find().toArray();
        res.json(allInquires);
    } catch (error) {
        next(error);
    }
});

// Update
router.put('/inquires/update/:id', async (req, res, next) => {
    try {
        await client.connect();
        const database = client.db('inquire_db');
        const inquire_messages = database.collection('inquire_messages');
        const query = {
            _id: req.params.id
        };
        const update = {
            $set: req.body
        };
        const updateResult = await inquire_messages.updateOne(query, update);
        res.json({
            matchedCount: updateResult.matchedCount
        });
    } catch (error) {
        next(error);
    }
});

// Delete
router.delete('/inquires/delete/:id', async (req, res, next) => {
    try {
        await client.connect();
        const database = client.db('inquire_db');
        const inquire_messages = database.collection('inquire_messages');
        const deleteResult = await inquire_messages.deleteOne({
            _id: new ObjectId(req.params.id)
        });
        res.json({
            deletedCount: deleteResult.deletedCount
        });
    } catch (error) {
        next(error);
    }
});

/* This code block defines CRUD (Create, Read, Update, Delete) operations for a collection named
`today_inquires_collection` in a MongoDB database named `inquire_db`. Here's a breakdown of what
each part of the code does: */
// CRUD for inquire_db/today_inquires_collection
// Create
router.post('/today_inquires/create', async (req, res, next) => {
    try {
        await client.connect();
        const {
            order,
            inquire_id
        } = req.body;
        const requiredFields = {
            order,
            inquire_id
        };
        const missingFields = Object.entries(requiredFields).filter(([key, value]) => !value).map(([key]) => key);
        if (missingFields.length > 0) {
            return res.status(400).json({
                error: 'Incomplete data',
                missing: missingFields
            });
        }
        const database = client.db('inquire_db');
        const today_inquire_collection = database.collection('today_inquire_collection');
        const existingInquire = await today_inquire_collection.findOne({
            order,
            'inquire_id.$oid': inquire_id.$oid
        });
        if (existingInquire) return res.status(200).json({
            message: 'Entry already exists'
        });
        const result = await today_inquire_collection.insertOne(req.body);
        res.json({
            id: result.insertedId
        });
    } catch (error) {
        next(error);
    }
});

// Read
router.get('/today_inquires/read', async (req, res, next) => {
    try {
        await client.connect();
        const database = client.db('inquire_db');
        const today_inquire_collection = database.collection('today_inquire_collection');
        const allInquires = await today_inquire_collection.find().toArray();
        res.json(allInquires);
    } catch (error) {
        next(error);
    }
});

// Update
router.put('/today_inquires/update/:id', async (req, res, next) => {
    try {
        await client.connect();
        const database = client.db('inquire_db');
        const today_inquire_collection = database.collection('today_inquire_collection');
        const query = {
            _id: req.params.id
        };
        const update = {
            $set: req.body
        };
        const updateResult = await today_inquire_collection.updateOne(query, update);
        res.json({
            matchedCount: updateResult.matchedCount
        });
    } catch (error) {
        next(error);
    }
});

// Delete
router.delete('/today_inquires/delete/:id', async (req, res, next) => {
    try {
        await client.connect();
        const database = client.db('inquire_db');
        const today_inquire_collection = database.collection('today_inquire_collection');
        const deleteResult = await today_inquire_collection.deleteOne({
            _id: new ObjectId(req.params.id)
        });
        res.json({
            deletedCount: deleteResult.deletedCount
        });
    } catch (error) {
        next(error);
    }
});

module.exports = router;
//offer_coa_upload_restful_api.js
const express = require("express");
const router = express.Router();
const mongoose = require("mongoose");
const multer = require("multer");

// MongoDB connection
const mongoUrl = "mongodb://localhost:27017/offer_db"; // Your MongoDB connection URL
mongoose.connect(mongoUrl, { useNewUrlParser: true });

// Define schema for PDF details
const PdfDetailsSchema = new mongoose.Schema(
  {
    pdf: Buffer,

  },
  { collection: "offer_messages" }
);

const PdfDetails = mongoose.model("PdfDetails", PdfDetailsSchema);

router.get("/get-offers-with-coa", async (req, res) => {
  try {
    const data = await PdfDetails.find({ pdf: { $exists: true } }, { _id: 1 }); // Filter by the existence of the pdf field
    res.send({ status: "ok", data: data.map(doc => doc._id) }); // Return only the ObjectIDs
  } catch (error) {
    res.json({ status: error });
  }
});

router.get("/get-offers-without-coa", async (req, res) => {
  try {
    const data = await PdfDetails.find({ pdf: { $exists: false } }, { _id: 1 }); // Filter by the existence of the pdf field
    res.send({ status: "ok", data: data.map(doc => doc._id) }); // Return only the ObjectIDs
  } catch (error) {
    res.json({ status: error });
  }
});


// Route for getting a specific PDF file
router.get("/pdf/:id", async (req, res) => {
  try {
    const id = req.params.id;
    const pdf = await PdfDetails.findById(id);

    if (!pdf) {
      return res.status(404).json({ error: 'PDF not found' });
    }

    // Set response header to indicate the content type
    res.setHeader('Content-Type', 'application/pdf');

    // Send the PDF content as the response
    res.send(pdf.pdf);
  } catch (error) {
    console.error('Error fetching PDF:', error);
    res.status(500).json({ error: 'Error fetching PDF' });
  }
});

module.exports = router;
//offer_model.js
//Offer Schema is defined here
const mongoose = require('mongoose');

const offerSchema = new mongoose.Schema({
    sender: String,
    timestamp: String,
    user: {
        userId: String,
        category: String
    },
    country: String,
    mine_name: String,
    typical_gar: String,
    typical_ash: String,
    typical_sulphur: String,
    volume: String,
    laycan: String,
    port: String,
    status: String,
    pdf: Buffer // Store PDF data as Buffer
});

// Create model from schema
const Offer = mongoose.model('Offer', offerSchema);

module.exports = Offer;
//offer_restful_api.js
// Purpose: Create a RESTful API for Offer's Database CRUD operations on a MongoDB database
const express = require('express');
const router = express.Router();
const {
    MongoClient,
    ObjectId
} = require("mongodb");
const multer = require("multer");
const Offer = require('./offer_model');

const upload = multer({ storage: multer.memoryStorage() }); // Store files in memory

// Replace the uri string with your connection string.
const uri = "mongodb://localhost:27017";
const client = new MongoClient(uri);

/* The above code is implementing CRUD (Create, Read, Update, Delete) operations for a MongoDB
collection named 'offer_messages' in the 'offer_db' database. Here is a summary of each operation: */
//CRUD operations for offer_db/offers
//Create
/*
// Sample request body for creating a new offer message
{
    "sender": "admin",
    "timestamp": "2024-03-25 10:31:35",
    "user": {
        "userId": "ADMIN",
        "category": "admin"
    },
    "country": "Russia",
    "mine_name": "Elga HCC Select",
    "typical_gar": "6200",
    "typical_ash": "16",
    "typical_sulphur": "NaN",
    "volume": "NaN",
    "laycan": "NaN",
    "port": "Vanino/ Vostochny",
    "status": "NaN",
    "pdf": "PDF data in base64 format"
}
*/
router.post('/offers/create', upload.single('pdf'), async (req, res, next) => {
    try {
        const {
            sender,
            timestamp,
            user,
            country,
            mine_name,
            typical_gar,
            typical_ash,
            typical_sulphur,
            volume,
            laycan,
            port,
            status,
            //esline-disable-next-line no-unused-vars
            pdf
        } = req.body;

        // Check if data is complete
        let missingFields = [];
        if (!sender) missingFields.push('sender');
        if (!timestamp) missingFields.push('timestamp');
        if (!user) missingFields.push('user');
        if (!country) missingFields.push('country');
        if (!mine_name) missingFields.push('mine_name');
        if (!typical_gar) missingFields.push('typical_gar');
        if (!typical_ash) missingFields.push('typical_ash');
        if (!typical_sulphur) missingFields.push('typical_sulphur');
        if (!volume) missingFields.push('volume');
        if (!laycan) missingFields.push('laycan');
        if (!port) missingFields.push('port');
        if (!status) missingFields.push('status');

        if (missingFields.length > 0) {
            return res.status(400).json({
                error: 'Incomplete data',
                missing: missingFields
            });
        }

        //check if pdf is present and valid
        if (!req.file) {
            return res.status(400).json({
                error: 'No PDF provided'
            });
        }
        const pdfData = req.file.buffer; // Retrieve PDF data from request buffer

        //Create a new offer with pdf
        const newOffer = new Offer({
            sender,
            timestamp,
            user,
            country,
            mine_name,
            typical_gar,
            typical_ash,
            typical_sulphur,
            volume,
            laycan,
            port,
            status,
            pdf: pdfData
        });

        // Save the new offer to the database
        await client.connect();
        const database = client.db('offer_db');
        const offer_messages = database.collection('offer_messages');

        // Check if the entry already exists
        const existingOffer = await offer_messages.findOne({
            sender,
            timestamp,
            'user._id': user._id // For backward compatibility
        });

        // If user._id is not present, check for user.wa_id
        if (!existingOffer && user.wa_id) {
            const existingOfferByWaId = await offer_messages.findOne({
                sender,
                timestamp,
                'user.wa_id': user.wa_id
            });

            if (existingOfferByWaId) {
                return res.status(200).json({
                    message: 'Entry already exists'
                });
            }
        }

        // If neither user._id nor user.wa_id is present, proceed with insertion
        if (!existingOffer) {
            const result = await offer_messages.insertOne(newOffer);

            return res.status(201).json({
                id: result.insertedId
            });
        }

        return res.status(200).json({
            message: 'Entry already exists'
        });
    } catch (error) {
        next(error);
    } finally {
        await client.close();
    }
});

//Read
router.get('/offers/read', async (req, res, next) => {
    try {
        await client.connect();
        const database = client.db('offer_db');
        const offer_messages = database.collection('offer_messages');

        const allOffers = await offer_messages.find().toArray();

        res.json(allOffers);
    } catch (error) {
        next(error);
    } finally {
        await client.close();
    }
});

//Update
router.put('/offers/update/:id', async (req, res, next) => {
    try {
        await client.connect();
        const database = client.db('offer_db');
        const offer_messages = database.collection('offer_messages');

        const query = {
            _id: req.params.id
        };
        const update = {
            $set: req.body
        };

        const updateResult = await offer_messages.updateOne(query, update);

        res.json({
            matchedCount: updateResult.matchedCount
        });
    } catch (error) {
        next(error);
    } finally {
        await client.close();
    }
});

//Delete
router.delete('/offers/delete/:id', async (req, res, next) => {
    try {
        await client.connect();
        const database = client.db('offer_db');
        const offer_messages = database.collection('offer_messages');

        const deleteResult = await offer_messages.deleteOne({
            _id: new ObjectId(req.params.id)
        });

        res.json({
            deletedCount: deleteResult.deletedCount
        });
    } catch (error) {
        next(error);
    } finally {
        await client.close();
    }
});

/* The above code is implementing CRUD (Create, Read, Update, Delete) operations for a MongoDB
collection named `today_offer_collection` in the `offer_db` database. Here is a breakdown of each
operation: */
//CRUD for offer_db/today_offer_collection
//CRUD operations
//Create
router.post('/today_offer/create', async (req, res, next) => {
    try {
        const {
            order,
            offer_id
        } = req.body;

        // Check if data is complete
        let missingFields = [];
        if (!order) missingFields.push('order');
        if (!offer_id) missingFields.push('offer_id');

        if (missingFields.length > 0) {
            return res.status(400).json({
                error: 'Incomplete data',
                missing: missingFields
            });
        }

        await client.connect();
        const database = client.db('offer_db');
        const today_offer_collection = database.collection('today_offer_collection');

        // Check if the entry already exists
        const existingOffer = await today_offer_collection.findOne({
            order,
            'offer_id.$oid': offer_id.$oid
        });
        if (existingOffer) {
            return res.status(200).json({
                message: 'Entry already exists'
            });
        }

        const new_offer = req.body;
        const result = await today_offer_collection.insertOne(new_offer);

        res.json({
            id: result.insertedId
        });
    } catch (error) {
        next(error);
    } finally {
        await client.close();
    }
});

//Read
router.get('/today_offer/read', async (req, res, next) => {
    try {
        await client.connect();
        const database = client.db('offer_db');
        const today_offer_collection = database.collection('today_offer_collection');

        const allOffers = await today_offer_collection.find().toArray();

        res.json(allOffers);
    } catch (error) {
        next(error);
    } finally {
        await client.close();
    }
});

//Update
router.put('/today_offer/update/:id', async (req, res, next) => {
    try {
        await client.connect();
        const database = client.db('offer_db');
        const today_offer_collection = database.collection('today_offer_collection');

        const query = {
            _id: req.params.id
        };
        const update = {
            $set: req.body
        };

        const updateResult = await today_offer_collection.updateOne(query, update);

        res.json({
            matchedCount: updateResult.matchedCount
        });
    } catch (error) {
        next(error);
    } finally {
        await client.close();
    }
});

//Delete
router.delete('/today_offer/delete/:id', async (req, res, next) => {
    try {
        await client.connect();
        const database = client.db('offer_db');
        const today_offer_collection = database.collection('today_offer_collection');

        const deleteResult = await today_offer_collection.deleteOne({
            _id: new ObjectId(req.params.id)
        });

        res.json({
            deletedCount: deleteResult.deletedCount
        });
    } catch (error) {
        next(error);
    } finally {
        await client.close();
    }
});

/* The above code is implementing CRUD (Create, Read, Update, Delete) operations for a MongoDB
collection named 'selected_offer_messages' in the 'offer_db' database. Here is a summary of each
operation: */
//CRUD for offer_db/selected_offers
//CRUD operations
//Create
router.post('/selected_offers/create', async (req, res, next) => {
    try {
        const {
            order,
            sender,
            timestamp,
            offer_id
        } = req.body;

        // Check if data is complete
        let missingFields = [];
        if (!order) missingFields.push('order');
        if (!offer_id) missingFields.push('offer_id');
        if (!sender) missingFields.push('sender');
        if (!timestamp) missingFields.push('timestamp');

        if (missingFields.length > 0) {
            return res.status(400).json({
                error: 'Incomplete data',
                missing: missingFields
            });
        }

        await client.connect();
        const database = client.db('offer_db');
        const selected_offers = database.collection('selected_offer_messages');

        // Check if the entry already exists
        const existingOffer = await selected_offers.findOne({
            order,
            'offer_id.$oid': offer_id.$oid,
            sender,
        });
        if (existingOffer) {
            return res.status(200).json({
                message: 'Entry already exists'
            });
        }

        const new_offer = req.body;
        const result = await selected_offers.insertOne(new_offer);

        res.json({
            id: result.insertedId
        });
    } catch (error) {
        next(error);
    } finally {
        await client.close();
    }
});

//Read
router.get('/selected_offers/read', async (req, res, next) => {
    try {
        await client.connect();
        const database = client.db('offer_db');
        const selected_offers = database.collection('selected_offer_messages');

        const allOffers = await selected_offers.find().toArray();

        res.json(allOffers);
    } catch (error) {
        next(error);
    } finally {
        await client.close();
    }
});

//Update
router.put('/selected_offers/update/:id', async (req, res, next) => {
    try {
        await client.connect();
        const database = client.db('offer_db');
        const selected_offers = database.collection('selected_offer_messages');

        const query = {
            _id: req.params.id
        };
        const update = {
            $set: req.body
        };

        const updateResult = await selected_offers.updateOne(query, update);

        res.json({
            matchedCount: updateResult.matchedCount
        });
    } catch (error) {
        next(error);
    } finally {
        await client.close();
    }
});

//Delete
router.delete('/selected_offers/delete/:id', async (req, res, next) => {
    try {
        await client.connect();
        const database = client.db('offer_db');
        const selected_offers = database.collection('selected_offer_messages');

        const deleteResult = await selected_offers.deleteOne({
            _id: new ObjectId(req.params.id)
        });

        res.json({
            deletedCount: deleteResult.deletedCount
        });
    } catch (error) {
        next(error);
    } finally {
        await client.close();
    }
});

module.exports = router;
//restful_api_main.js
const express = require("express");
const bodyParser = require("body-parser");
const offer_api = require("./offer_restful_api");
const user_api = require("./user_restful_api");
const inquire_api = require("./inquire_restful_api");
const offer_coa_upload_api = require("./offer_coa_upload_restful_api");
const cors = require("cors");
const axios = require("axios");
const mongoose = require("mongoose");

/* The code snippet you provided is connecting the Express application to a MongoDB database. Here's a
breakdown of what it does: */
// Connect to MongoDB
mongoose
  .connect("mongodb://localhost:27017/offer_db", {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  })
  .then(() => console.log("MongoDB connected"))
  .catch((err) => console.error("MongoDB connection error:", err));

// Create a new express application
const app = express();
app.use(bodyParser.json());
app.use(cors());

/**
 * The function `authenticateApiKey` is a middleware used for API key authentication in a Node.js
 * application.
 * @param req - The `req` parameter in the `authenticateApiKey` function stands for the request object.
 * It contains information about the HTTP request made to the server, including headers, parameters,
 * body, and more. In this case, the function is extracting the value of the `x-api-key` header from
 * the
 * @param res - The `res` parameter in the `authenticateApiKey` function stands for the response object
 * in Node.js. It is used to send a response back to the client making the request. In this case, the
 * function is checking for the presence and validity of an API key in the request headers, and if
 * @param next - The `next` parameter in the `authenticateApiKey` function is a callback function that
 * is used to pass control to the next middleware function in the request-response cycle. When called,
 * it tells Express to move on to the next middleware function in the chain. This allows you to chain
 * multiple middleware functions together
 * @returns In the provided code snippet, if the API key is not provided or is invalid, a response with
 * an error message and a status code of 401 (Unauthorized) is being returned. If the API key is valid,
 * the `next()` function is called to proceed to the next middleware or route handler in the
 * application.
 */
// Middleware for API key authentication
function authenticateApiKey(req, res, next) {
  const apiKey = req.headers["x-api-key"];

  // Check if API key is provided
  if (!apiKey) {
    return res.status(401).json({
      error: "No API key provided",
    });
  }

  // Check if API key is valid
  // Replace 'your_api_key' with your actual API key
  if (apiKey !== "aniruddhaqwerty1234") {
    return res.status(401).json({
      error: "Invalid API key",
    });
  }

  next();
}

/* The code snippet you provided is setting up health check endpoints for different components of your
application, namely Flask, Express, and MongoDB. These endpoints are used to verify the health
status of each component. */
// Health check endpoint for Flask
app.get("/api/v1/health/flask", async (req, res) => {
  try {
    // Make a request to the Flask health check endpoint
    const response = await axios.get("http://localhost:5000/api/v1/health");

    // Check if the Flask server is healthy
    if (response.data.message === "Flask server is running!") {
      res.status(200).json({
        message: "Flask server is healthy",
      });
    } else {
      res.status(500).json({
        error: "Flask server is not healthy",
      });
    }
  } catch (error) {
    console.error("Error while checking Flask server health:", error);
    res.status(500).json({
      error: "Error while checking Flask server health",
    });
  }
});

// Health check endpoint for Express
app.get("/api/v1/health/express", (req, res) => {
  // Check if the Express server is healthy
  res.status(200).json({
    message: "Express server is healthy",
  });
});

// Health check endpoint for MongoDB
app.get("/api/v1/health/mongodb", (req, res) => {
  // Check if the MongoDB connection is open
  if (mongoose.connection.readyState === 1) {
    res.status(200).json({
      message: "MongoDB connection is open",
    });
  } else {
    res.status(500).json({
      error: "MongoDB connection is closed",
    });
  }
});
// Use the API key authentication middleware
app.use(authenticateApiKey);

app.use("/offer_db", offer_api);
app.use("/user_data", user_api);
app.use("/inquire_db", inquire_api);
app.use("/offer_coa_upload", offer_coa_upload_api);

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    error: "Internal server error",
  });
});

// Start the Express server
app.listen(3000, () => console.log("Server is running on port 3000"));
//user_restful_api.js
const express = require('express');
const router = express.Router();
const {
    MongoClient,
    ObjectId
} = require("mongodb");

// Replace the uri string with your connection string.
const uri = "mongodb://localhost:27017";
const client = new MongoClient(uri);

/* This code snippet is defining CRUD (Create, Read, Update, Delete) operations for a user database
using Express.js and MongoDB. Here's a breakdown of each operation: */
//CRUD operations for User's Database
//Create
router.post('/users/create', async (req, res, next) => {
    try {
        console.log("Creating a new user...");
        const {
            wa_id,
            category,
            userId
        } = req.body;

        // Check if data is complete
        let missingFields = [];
        if (!wa_id && !userId) {
            missingFields.push('wa_id or userId');
        }
        if (!category) {
            missingFields.push('category');
        }

        if (missingFields.length > 0) {
            return res.status(400).json({
                error: 'Incomplete data',
                missing: missingFields
            });
        }

        await client.connect();
        console.log("Connected to the database");

        const database = client.db('user_data');
        const user = database.collection('users');

        // Check if the entry already exists
        const existing_user = await user.findOne({
            wa_id,
            category,
            userId
        });
        if (existing_user) {
            console.log("Entry already exists");
            return res.status(200).json({
                message: 'Entry already exists'
            });
        }

        const new_user = req.body;
        const result = await user.insertOne(new_user);
        console.log("New user created:", result.insertedId);

        res.json({
            id: result.insertedId
        });
    } catch (error) {
        console.error("Error creating user:", error);
        next(error);
    } finally {
        await client.close();
        console.log("Database connection closed");
    }
});

//Read
router.get('/users/read', async (req, res, next) => {
    try {
        console.log("Reading users from the database...");
        await client.connect();
        console.log("Connected to the database");

        const database = client.db('user_data');
        const user = database.collection('users');
        const result = await user.find({}).toArray();

        console.log("Users retrieved:", result.length);
        res.json(result);
    } catch (error) {
        console.error("Error reading users:", error);
        next(error);
    } finally {
        await client.close();
        console.log("Database connection closed");
    }
});

//Update
router.put('/users/update/:id', async (req, res, next) => {
    try {
        console.log("Updating user...");
        const id = req.params.id;
        const {
            wa_id,
            category,
            userId
        } = req.body;

        // Check if data is complete
        let missingFields = [];
        if (!wa_id && !userId) {
            missingFields.push('wa_id or userId');
        }
        if (!category) {
            missingFields.push('category');
        }

        if (missingFields.length > 0) {
            return res.status(400).json({
                error: 'Incomplete data',
                missing: missingFields
            });
        }

        await client.connect();
        console.log("Connected to the database");

        const database = client.db('user_data');
        const user = database.collection('users');

        const result = await user.updateOne({
            _id: new ObjectId(id)
        }, {
            $set: req.body
        });

        if (result.matchedCount === 0) {
            console.log("User not found");
            throw new NotFoundError('Entry not found');
        }

        console.log("User updated:", id);
        res.json({
            message: 'Entry updated'
        });
    } catch (error) {
        console.error("Error updating user:", error);
        next(error);
    } finally {
        await client.close();
        console.log("Database connection closed");
    }
});

//Delete
router.delete('/users/delete/:id', async (req, res, next) => {
    try {
        console.log("Deleting user...");
        await client.connect();
        console.log("Connected to the database");

        const database = client.db('user_data');
        const user = database.collection('users');

        const result = await user.deleteOne({
            _id: new ObjectId(req.params.id)
        });

        if (result.deletedCount === 0) {
            console.log("User not found");
            throw new NotFoundError('Entry not found');
        }

        console.log("User deleted:", req.params.id);
        res.json({
            message: 'Entry deleted'
        });
    } catch (error) {
        console.error("Error deleting user:", error);
        next(error);
    } finally {
        await client.close();
        console.log("Database connection closed");
    }
});

module.exports = router;
